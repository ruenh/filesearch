/**
 * Documents API functions
 * Requirements: 3.1, 3.2, 3.3, 3.4, 4.1, 5.1, 8.3
 */
import { apiClient } from "./client";
import type { Document, Version } from "@/types";

interface DocumentResponse {
  id: string;
  storage_id: string;
  folder_id?: string;
  name: string;
  file_type: "txt" | "pdf" | "docx" | "md" | "image";
  size: number;
  is_favorite: boolean;
  is_archived: boolean;
  is_deleted: boolean;
  has_ocr_text?: boolean; // Requirements: 10.1, 10.2
  ocr_text?: string;
  deleted_at?: string;
  created_at: string;
  updated_at: string;
  versions?: VersionResponse[];
  tags?: TagResponse[];
}

interface VersionResponse {
  id: string;
  document_id: string;
  version_number: number;
  size: number;
  created_at: string;
  created_by?: string;
}

interface TagResponse {
  id: string;
  name: string;
  color: string;
  is_auto_generated: boolean;
}

export type SortField =
  | "name"
  | "created_at"
  | "updated_at"
  | "size"
  | "file_type";
export type SortOrder = "asc" | "desc";

interface ListDocumentsParams {
  storageId: string;
  folderId?: string;
  tag?: string;
  favorite?: boolean;
  includeDeleted?: boolean;
  sortBy?: SortField;
  order?: SortOrder;
}

// Transform API response to frontend Document type
function transformDocument(data: DocumentResponse): Document {
  return {
    id: data.id,
    storageId: data.storage_id,
    folderId: data.folder_id,
    name: data.name,
    type: data.file_type,
    size: data.size,
    isFavorite: data.is_favorite,
    isArchived: data.is_archived,
    hasOcrText: data.has_ocr_text, // Requirements: 10.1, 10.2
    ocrText: data.ocr_text,
    createdAt: new Date(data.created_at),
    updatedAt: new Date(data.updated_at),
    tags:
      data.tags?.map((t) => ({
        id: t.id,
        name: t.name,
        color: t.color,
        isAutoGenerated: t.is_auto_generated,
      })) || [],
    versions:
      data.versions?.map((v) => ({
        id: v.id,
        documentId: v.document_id,
        versionNumber: v.version_number,
        size: v.size,
        createdAt: new Date(v.created_at),
        createdBy: v.created_by || "",
      })) || [],
  };
}

/**
 * List documents in a storage
 * Requirements: 8.3, 24.2
 */
export async function listDocuments(
  params: ListDocumentsParams
): Promise<Document[]> {
  const queryParams: Record<string, string> = {
    storage_id: params.storageId,
  };

  if (params.folderId) {
    queryParams.folder_id = params.folderId;
  }
  if (params.tag) {
    queryParams.tag = params.tag;
  }
  if (params.favorite !== undefined) {
    queryParams.favorite = params.favorite.toString();
  }
  if (params.includeDeleted) {
    queryParams.include_deleted = "true";
  }
  if (params.sortBy) {
    queryParams.sort_by = params.sortBy;
  }
  if (params.order) {
    queryParams.order = params.order;
  }

  const response = await apiClient.get<DocumentResponse[]>(
    "/documents",
    queryParams
  );
  return response.map(transformDocument);
}

/**
 * Get document details
 * Requirements: 4.1, 4.3
 */
export async function getDocument(
  documentId: string,
  includeVersions = false
): Promise<Document> {
  const params: Record<string, string> = {};
  if (includeVersions) {
    params.include_versions = "true";
  }
  const response = await apiClient.get<DocumentResponse>(
    `/documents/${documentId}`,
    params
  );
  return transformDocument(response);
}

/**
 * Upload a new document
 * Requirements: 3.1, 3.2, 3.3
 */
export async function uploadDocument(
  file: File,
  storageId: string,
  folderId?: string,
  onProgress?: (progress: number) => void
): Promise<Document> {
  const formData = new FormData();
  formData.append("file", file);
  formData.append("storage_id", storageId);
  if (folderId) {
    formData.append("folder_id", folderId);
  }

  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();

    xhr.upload.addEventListener("progress", (event) => {
      if (event.lengthComputable && onProgress) {
        const progress = Math.round((event.loaded / event.total) * 100);
        onProgress(progress);
      }
    });

    xhr.addEventListener("load", () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        const response = JSON.parse(xhr.responseText) as DocumentResponse;
        resolve(transformDocument(response));
      } else {
        reject(new Error(`Upload failed: ${xhr.statusText}`));
      }
    });

    xhr.addEventListener("error", () => {
      reject(new Error("Upload failed: Network error"));
    });

    xhr.open("POST", "/api/documents");
    xhr.send(formData);
  });
}

/**
 * Update document metadata
 * Requirements: 5.1
 */
export async function updateDocument(
  documentId: string,
  data: {
    name?: string;
    folderId?: string;
    isFavorite?: boolean;
    isArchived?: boolean;
  }
): Promise<Document> {
  const payload: Record<string, unknown> = {};
  if (data.name !== undefined) payload.name = data.name;
  if (data.folderId !== undefined) payload.folder_id = data.folderId;
  if (data.isFavorite !== undefined) payload.is_favorite = data.isFavorite;
  if (data.isArchived !== undefined) payload.is_archived = data.isArchived;

  const response = await apiClient.put<DocumentResponse>(
    `/documents/${documentId}`,
    payload
  );
  return transformDocument(response);
}

/**
 * Delete document (move to trash)
 * Requirements: 3.4, 25.1
 */
export async function deleteDocument(documentId: string): Promise<void> {
  await apiClient.delete(`/documents/${documentId}`);
}

/**
 * Restore document from trash
 * Requirements: 25.3
 */
export async function restoreDocument(documentId: string): Promise<Document> {
  const response = await apiClient.post<DocumentResponse>(
    `/documents/${documentId}/restore`
  );
  return transformDocument(response);
}

/**
 * Get document versions
 * Requirements: 26.2
 */
export async function listVersions(documentId: string): Promise<Version[]> {
  const response = await apiClient.get<VersionResponse[]>(
    `/documents/${documentId}/versions`
  );
  return response.map((v) => ({
    id: v.id,
    documentId: v.document_id,
    versionNumber: v.version_number,
    size: v.size,
    createdAt: new Date(v.created_at),
    createdBy: v.created_by || "",
  }));
}

/**
 * Document content response for text files
 */
export interface DocumentContent {
  content: string;
  type: string;
  name: string;
  size: number;
}

/**
 * Get document content for viewing
 * Requirements: 4.1, 4.2
 */
export async function getDocumentContent(
  documentId: string
): Promise<DocumentContent> {
  const response = await apiClient.get<DocumentContent>(
    `/documents/${documentId}/content`
  );
  return response;
}

/**
 * Get document content URL for binary files (PDF, images)
 * Requirements: 4.1
 */
export function getDocumentContentUrl(documentId: string): string {
  return `/api/documents/${documentId}/content`;
}

/**
 * Get document download URL
 * Requirements: 4.1
 */
export function getDocumentDownloadUrl(documentId: string): string {
  return `/api/documents/${documentId}/download`;
}

/**
 * Update document content response
 */
export interface UpdateContentResponse {
  message: string;
  version: {
    id: string;
    document_id: string;
    version_number: number;
    size: number;
    created_at: string;
  };
  document: DocumentResponse;
}

/**
 * Update document content (for text files only)
 * Creates a new version when content is updated
 * Requirements: 34.3, 5.2
 */
export async function updateDocumentContent(
  documentId: string,
  content: string
): Promise<{ document: Document; versionNumber: number }> {
  const response = await apiClient.put<UpdateContentResponse>(
    `/documents/${documentId}/content`,
    { content }
  );
  return {
    document: transformDocument(response.document),
    versionNumber: response.version.version_number,
  };
}

// ============================================================================
// Favorites API
// Requirements: 24.1, 24.2, 24.3
// ============================================================================

interface ToggleFavoriteResponse {
  message: string;
  document: DocumentResponse;
}

/**
 * Toggle favorite status of a document
 * Requirements: 24.1, 24.3
 */
export async function toggleFavorite(
  documentId: string,
  isFavorite?: boolean
): Promise<Document> {
  const payload: Record<string, unknown> = {};
  if (isFavorite !== undefined) {
    payload.is_favorite = isFavorite;
  }

  const response = await apiClient.put<ToggleFavoriteResponse>(
    `/documents/${documentId}/favorite`,
    payload
  );
  return transformDocument(response.document);
}

interface ListFavoritesParams {
  storageId?: string;
  includeDeleted?: boolean;
  sortBy?: SortField;
  order?: SortOrder;
}

/**
 * List all favorite documents
 * Requirements: 24.2
 */
export async function listFavorites(
  params: ListFavoritesParams = {}
): Promise<Document[]> {
  const queryParams: Record<string, string> = {};

  if (params.storageId) {
    queryParams.storage_id = params.storageId;
  }
  if (params.includeDeleted) {
    queryParams.include_deleted = "true";
  }
  if (params.sortBy) {
    queryParams.sort_by = params.sortBy;
  }
  if (params.order) {
    queryParams.order = params.order;
  }

  const response = await apiClient.get<DocumentResponse[]>(
    "/documents/favorites",
    queryParams
  );
  return response.map(transformDocument);
}

// ============================================================================
// Archive API
// Requirements: 30.1, 30.2, 30.3
// ============================================================================

interface ToggleArchiveResponse {
  message: string;
  document: DocumentResponse;
}

/**
 * Toggle archive status of a document
 * Requirements: 30.1, 30.3
 */
export async function toggleArchive(
  documentId: string,
  isArchived?: boolean
): Promise<Document> {
  const payload: Record<string, unknown> = {};
  if (isArchived !== undefined) {
    payload.is_archived = isArchived;
  }

  const response = await apiClient.put<ToggleArchiveResponse>(
    `/documents/${documentId}/archive`,
    payload
  );
  return transformDocument(response.document);
}

interface ListArchivedParams {
  storageId?: string;
  includeDeleted?: boolean;
  sortBy?: SortField;
  order?: SortOrder;
}

/**
 * List all archived documents
 * Requirements: 30.2
 */
export async function listArchived(
  params: ListArchivedParams = {}
): Promise<Document[]> {
  const queryParams: Record<string, string> = {};

  if (params.storageId) {
    queryParams.storage_id = params.storageId;
  }
  if (params.includeDeleted) {
    queryParams.include_deleted = "true";
  }
  if (params.sortBy) {
    queryParams.sort_by = params.sortBy;
  }
  if (params.order) {
    queryParams.order = params.order;
  }

  const response = await apiClient.get<DocumentResponse[]>(
    "/documents/archived",
    queryParams
  );
  return response.map(transformDocument);
}

// ============================================================================
// Bulk Operations API
// Requirements: 27.1, 27.2, 27.3
// ============================================================================

interface BulkDeleteResponse {
  message: string;
  deleted_count: number;
  requested_count: number;
}

/**
 * Bulk delete documents (move to trash)
 * Requirements: 27.1, 27.2, 27.3
 */
export async function bulkDeleteDocuments(
  documentIds: string[]
): Promise<BulkDeleteResponse> {
  const response = await apiClient.post<BulkDeleteResponse>(
    "/documents/bulk/delete",
    { document_ids: documentIds }
  );
  return response;
}

interface BulkMoveResponse {
  message: string;
  moved_count: number;
  requested_count: number;
  target_folder_id: string | null;
}

/**
 * Bulk move documents to a folder
 * Requirements: 27.1, 27.2, 27.3
 */
export async function bulkMoveDocuments(
  documentIds: string[],
  folderId: string | null
): Promise<BulkMoveResponse> {
  const response = await apiClient.post<BulkMoveResponse>(
    "/documents/bulk/move",
    { document_ids: documentIds, folder_id: folderId }
  );
  return response;
}

interface BulkTagResponse {
  message: string;
  tagged_count: number;
  requested_count: number;
  tags: string[];
  action: "add" | "replace";
}

/**
 * Bulk add/replace tags on documents
 * Requirements: 27.1, 27.2, 27.3
 */
export async function bulkTagDocuments(
  documentIds: string[],
  tags: string[],
  action: "add" | "replace" = "add"
): Promise<BulkTagResponse> {
  const response = await apiClient.post<BulkTagResponse>(
    "/documents/bulk/tag",
    { document_ids: documentIds, tags, action }
  );
  return response;
}

interface BulkArchiveResponse {
  message: string;
  count: number;
  requested_count: number;
  is_archived: boolean;
}

/**
 * Bulk archive/unarchive documents
 * Requirements: 27.1, 27.2, 27.3
 */
export async function bulkArchiveDocuments(
  documentIds: string[],
  isArchived: boolean = true
): Promise<BulkArchiveResponse> {
  const response = await apiClient.post<BulkArchiveResponse>(
    "/documents/bulk/archive",
    { document_ids: documentIds, is_archived: isArchived }
  );
  return response;
}

interface BulkFavoriteResponse {
  message: string;
  count: number;
  requested_count: number;
  is_favorite: boolean;
}

/**
 * Bulk favorite/unfavorite documents
 * Requirements: 27.1, 27.2, 27.3
 */
export async function bulkFavoriteDocuments(
  documentIds: string[],
  isFavorite: boolean = true
): Promise<BulkFavoriteResponse> {
  const response = await apiClient.post<BulkFavoriteResponse>(
    "/documents/bulk/favorite",
    { document_ids: documentIds, is_favorite: isFavorite }
  );
  return response;
}

// ============================================================================
// OCR API
// Requirements: 10.1, 10.2, 10.3
// ============================================================================

/**
 * OCR text response
 */
export interface OcrTextResponse {
  document_id: string;
  document_name: string;
  has_ocr_text: boolean;
  ocr_text: string;
  text_length: number;
}

/**
 * Get OCR extracted text for a document
 * Requirements: 10.2
 */
export async function getDocumentOcr(
  documentId: string
): Promise<OcrTextResponse> {
  const response = await apiClient.get<OcrTextResponse>(
    `/documents/${documentId}/ocr`
  );
  return response;
}

/**
 * OCR processing response
 */
export interface OcrProcessResponse {
  document_id: string;
  document_name: string;
  success: boolean;
  has_ocr_text: boolean;
  ocr_text: string;
  text_length: number;
}

/**
 * Process or re-process OCR for a document
 * Requirements: 10.1, 10.2
 */
export async function processDocumentOcr(
  documentId: string
): Promise<OcrProcessResponse> {
  const response = await apiClient.post<OcrProcessResponse>(
    `/documents/${documentId}/ocr`
  );
  return response;
}

/**
 * Bulk OCR processing result
 */
export interface BulkOcrResult {
  document_id: string;
  document_name?: string;
  success: boolean;
  has_ocr_text?: boolean;
  text_length?: number;
  error?: string;
}

/**
 * Bulk OCR processing response
 */
export interface BulkOcrResponse {
  results: BulkOcrResult[];
  total: number;
  success_count: number;
  failed_count: number;
}

/**
 * Process OCR for multiple image documents
 * Requirements: 10.1, 10.2
 */
export async function bulkProcessOcr(
  documentIds: string[]
): Promise<BulkOcrResponse> {
  const response = await apiClient.post<BulkOcrResponse>(
    "/documents/bulk/ocr",
    { document_ids: documentIds }
  );
  return response;
}
